import {
    $query,
    $update,
    Record,
    Opt,
    Vec,
    nat64,
    StableBTreeMap,
    Principal,
    match,
    Result,
    ic,
    int
} from 'azle';

import { v4 as uuidv4 } from 'uuid';

// Define BlogPost type
type BlogPost = Record<{
    id: string;
    principal: Principal;
    title: string;
    content: string;
    author: string;
    createdAt: nat64;
    numberOfViews: int;
    commentIds: Vec<string>;
}>;

// Define CommentType type
type CommentType = Record<{
    id: string;
    authorName: string;
    principal: Principal;
    content: string;
    createdAt: nat64;
    blogPostId: string;
}>;

// Define payload types
type BlogPostPayload = Record<{
    title: string;
    content: string;
    author: string;
}>;

type CommentPayload = Record<{
    authorName: string;
    content: string;
}>;

// Create storage for blog posts and comments
const blogPostStorage = new StableBTreeMap<string, BlogPost>(0, 44, 1024);
const commentStorage = new StableBTreeMap<string, CommentType>(1, 44, 1024);


// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
    return str.trim().length == 0
}

function validateBlogPostPayload(payload: BlogPostPayload): Vec<string>{
    const errors: Vec<string> = [];
    if (isInvalidString(payload.author)){
        errors.push(`Author must not be empty. Current author='${payload.author}'.`)
    }
    if (isInvalidString(payload.content)){
        errors.push(`Content must not be empty. Current content='${payload.content}'.`)
    }
    if (isInvalidString(payload.title)){
        errors.push(`Title must not be empty. Current title='${payload.title}'.`)
    }
    return errors;
}

function validateCommentPayload(payload: CommentPayload): Vec<string>{
    const errors: Vec<string> = [];
    if (isInvalidString(payload.authorName)){
        errors.push(`Author name must not be empty. Current author name='${payload.authorName}'.`)
    }
    if (isInvalidString(payload.content)){
        errors.push(`Content must not be empty. Current content='${payload.content}'.`)
    }
    return errors;
}
// Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
    const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
    return regexExp.test(id);
}

// Query functions

// Retrieve all blog posts
$query
export function getBlogPosts(): Result<Vec<BlogPost>, string> {
    try {
        return Result.Ok(blogPostStorage.values());
    } catch (error) {
        return Result.Err<Vec<BlogPost>, string>('Failed while trying to get blog posts');
    }
};


// Update functions
// Retrieve a single blog post and increment view count
$update
export function getSingleBlogPost(id: string): Result<Opt<BlogPost>, string> {
    try {
        // Validate parameters
        if (!isValidUuid(id)) {
            return Result.Err(`Id=${id} is not in the valid uuid format.`);
        }

        const blogPostOpt = blogPostStorage.get(id);

        return match(blogPostOpt, {
            Some: (blogPost) => {
                // Increment the number of views when a blog post is viewed
                blogPost.numberOfViews += BigInt(1);
                blogPostStorage.insert(blogPost.id, blogPost);
                return Result.Ok<Opt<BlogPost>, string>(blogPostOpt);
            },
            None: () => Result.Err<Opt<BlogPost>, string>(`A blog post with id=${id} not found`),
        });
    } catch (error) {
        return Result.Err<Opt<BlogPost>, string>('Failed while trying to get a blog post');
    }
}

// Create a new blog post
$update
export function createBlogPost(payload: BlogPostPayload): Result<string, string> {
    try {
        let payloadErrors = validateBlogPostPayload(payload);

        // Validate payload properties
        if (payloadErrors.length) {
            return Result.Err<string, string>(`Invalid payload. Errors=[${payloadErrors}]`);
        }

        const blogPost: BlogPost = {
            id: uuidv4(),
            principal: ic.caller(),
            createdAt: ic.time(),
            numberOfViews: BigInt(0),
            commentIds: [],
            title: payload.title,
            content: payload.content,
            author: payload.author
        };
        blogPostStorage.insert(blogPost.id, blogPost);

        return Result.Ok('Blog post created successfully');
    } catch (error) {
        return Result.Err<string, string>('Failed while trying to create a blog post');
    }
}

// Update an existing blog post
$update
export function updateBlogPost(payload: BlogPostPayload, blogPostID: string): Result<BlogPost, string> {
    // Validate parameters
    if (!isValidUuid(blogPostID)) {
        return Result.Err(`blogPostId=${blogPostID} is not in the valid uuid format.`);
    }

    let payloadErrors = validateBlogPostPayload(payload);

    // Validate payload properties
    if (payloadErrors.length) {
        return Result.Err<BlogPost, string>(`Invalid payload. Errors=[${payloadErrors}]`);
    }
    const blogPostOpt = blogPostStorage.get(blogPostID);

    return match(blogPostOpt, {
        Some: (blogPost) => {
            if (ic.caller().toString() !== blogPost.principal.toString()){
                return  Result.Err<BlogPost, string>("Caller is not the principal of the blog post's author.")
            }
            // Set each property individually instead of spreading the payload
            const updatedBlogPost: BlogPost = {
                ...blogPost,
                title: payload.title,
                content: payload.content,
                author: payload.author
            };

            blogPostStorage.insert(blogPost.id, updatedBlogPost);

            return Result.Ok<BlogPost, string>(updatedBlogPost);
        },
        None: () => Result.Err<BlogPost, string>(`A blog post with id=${blogPostID} not found`),
    });
}

// Delete functions

// Delete a blog post
$update
export function deleteBlogPost(id: string): Result<string, string> {
    // Validate parameters
    if (!isValidUuid(id)) {
        return Result.Err(`Id=${id} is not in the valid uuid format.`);
    }

    const blogPostOpt = blogPostStorage.get(id);

    return match(blogPostOpt, {
        Some: (blogPost) => {
            if (ic.caller().toString() !== blogPost.principal.toString()){
                return  Result.Err<string, string>("Caller is not the principal of the blog post's author.")
            }
            blogPostStorage.remove(id);
            return Result.Ok<string, string>('Blog post deleted successfully');
        },
        None: () => Result.Err<string, string>(`A blog post with id=${id} not found`),
    });
}

// Create a new comment for a blog post
$update
export function addComment(payload: CommentPayload, blogPostID: string): Result<string, string> {
    // Validate parameters
    if (!isValidUuid(blogPostID)) {
        return Result.Err(`blogPostId=${blogPostID} is not in the valid uuid format.`);
    }

    const blogPostOpt = blogPostStorage.get(blogPostID);

    return match(blogPostOpt, {
        Some: (blogPost) => {
            let payloadErrors = validateCommentPayload(payload);

            // Validate payload properties
            if (payloadErrors.length) {
                return Result.Err<string, string>(`Invalid payload. Errors=[${payloadErrors}]`);
            }

            // Set each property individually instead of spreading the payload
            const comment: CommentType = {
                id: uuidv4(),
                principal: ic.caller(),
                blogPostId: blogPost.id,
                createdAt: ic.time(),
                ...payload,
            };

            commentStorage.insert(comment.id, comment);
            blogPost.commentIds.push(comment.id);
            blogPostStorage.insert(blogPost.id, blogPost);

            return Result.Ok<string, string>('Comment created successfully');
        },
        None: () => Result.Err<string, string>(`A blog post with id=${blogPostID} not found`),
    });
}

// Query functions

// Retrieve comments for a blog post
$query
export function getCommentsByBlogPost(blogPostID: string): Result<Vec<CommentType>, string> {
    // Validate parameters
    if (!isValidUuid(blogPostID)) {
        return Result.Err(`blogPostId=${blogPostID} is not in the valid uuid format.`);
    }

    const blogPostOpt = blogPostStorage.get(blogPostID);

    return match(blogPostOpt, {
        Some: (blogPost) => {
            const blogPostComments = commentStorage.values().filter(
                (comment: CommentType) => comment.blogPostId !== blogPost.id
            );

            return Result.Ok<Vec<CommentType>, string>(blogPostComments);
        },
        None: () => Result.Err<Vec<CommentType>, string>(`A blog post with id=${blogPostID} not found`),
    });
}

// Retrieve most popular blog posts
$query
export function getMostPopularBlogPosts(numberOfBlogPosts: int): Result<Vec<BlogPost>, string> {
    try {
        const blogPosts = blogPostStorage.values();
        blogPosts.sort((a: BlogPost, b: BlogPost) => {
            const aPopularity = a.commentIds.length + Number(a.numberOfViews);
            const bPopularity = b.commentIds.length + Number(b.numberOfViews);

            return bPopularity - aPopularity;
        });

        return Result.Ok(blogPosts.slice(0, Number(numberOfBlogPosts)));
    } catch (error) {
        return Result.Err<Vec<BlogPost>, string>('Failed while trying to get most popular blog posts');
    }
}

// A workaround to make the uuid package work with Azle
globalThis.crypto = {
    // @ts-ignore
    getRandomValues: () => {
        let array = new Uint8Array(32);

        for (let i = 0; i < array.length; i++) {
            array[i] = Math.floor(Math.random() * 256);
        }

        return array;
    },
};
